[{"ver":"0.1","info":{"id":"wcVSz3","date":"1750476729","viewed":11,"name":"026 - GDG 2","username":"PiGIon","description":"Cool effects with blobs","likes":0,"published":2,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Avoids color banding\n#define DITHERING TRUE\n\n#define PI 3.14159265\n\n\/\/#define time sin(iTime\/1.)\n\n\/\/ GDG colors\n#define cr vec3(0.918, 0.265, 0.210)\n#define cb vec3(0.260, 0.520, 0.955)\n#define cy vec3(0.982, 0.739, 0.020)\n#define cg vec3(0.045, 0.617, 0.347)\n\n\/\/ From inigo quilez SDF page\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\/* Gradient noise from Jorge Jimenez's presentation: *\/\n\/* http:\/\/www.iryoku.com\/next-generation-post-processing-in-call-of-duty-advanced-warfare *\/\nfloat gradientNoise(in vec2 uv)\n{\n\treturn fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n}\n\n\/\/ Returns if uv is inside a blob of flare\nfloat flare(vec2 uv, vec2 pos) {\n    \/\/ Transform uv for distortion of the blob\n    vec2 cuv = (log2(uv+1.0) - pos)*2.;\n    \/\/ Dot between uv itself is distance, creates a circle \n    return 1.3 - dot(cuv, cuv);\n}\n\n\/\/ returns a back and forth 0.0 to 1.0 per second\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    \/\/ step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    \/\/ since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    \/\/ this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\nvec3 gdgLogo(vec2 uv, vec3 bg) {\n    \/\/ Width of the lines\n    float w = 0.48;\n    \/\/ Angle as vec2\n    float ang = radians(30.);\n    vec2 a = normalize(vec2(cos(ang), sin(ang)));\n\n    \/\/ Adjusted UV for the logo\n    vec2 nuv = uv - vec2(1.7, -.5);\n\n    float time = iTime \/ 2.3;\n\n    \/\/ 'cycleDuration' controls how long each cycle (plus pause) lasts\n    \/\/ 'pauseRatio' specifies the percentage of the cycle duration paused [0.0, 1.0]\n    float cycleDuration = 14.0;    \/\/ total duration (active + pause)\n    float pauseRatio = 0.2;        \/\/ pause ratio\n\n    \/\/ normalized cycle [0.0, 1.0]\n    float cycleTime = mod(time, cycleDuration) \/ cycleDuration;\n\n    \/\/ creating a smooth cycle with pause at 0\n    float activeTime = clamp(cycleTime - pauseRatio, 0.0, 1.0 - pauseRatio) \/ (1.0 - pauseRatio);\n    float c = sin(activeTime * PI);  \/\/ smoothly from 0.0 to 1.0 back to 0.0 each cycle\n\n    \/\/ Distort angle with space\n    a += c*(cos(uv.x+1.0) * cos(uv.y-10.*2.)*cos(uv) - a)*2.;\n\n    float ratio = clamp(time, 0.0, 1.0);\n    float aa = max(0.01, 4.0 * c * ratio);\n    float add = min(c + 1.0, 1.4);\n\n    \/\/ Accumulate colors as vec4 (color.rgb, alpha)\n    vec4 cumulativeCol = vec4(0.0);\n\n    \/\/ Right yellow segment\n    float d = sdSegment(nuv + c*vec2(sin(time*0.2)*1.2, cos(time*0.18)*1.5)*c,\n                        -a + vec2(sin(time*0.2)*1.2, cos(time*0.18)*1.5)*c, \n                        a - vec2(cos(time*0.15)*-3.3, sin(time*0.12+time*0.05)*4.2)*c);\n    float alphaCy = 1.0 - smoothstep(w, w + aa, abs(d));\n    cumulativeCol = mix(cumulativeCol, vec4(cy * add, alphaCy), alphaCy);\n\n    \/\/ Right green segment\n    d = sdSegment(nuv - c*vec2(sin(time*0.9)*4.2, cos(time*0.18)*1.5),\n                  a - vec2(sin(time*0.13)*6.1, cos(time*0.17)*1.4)*c,\n                  vec2(-a.x + sin(time*0.1+time*0.08)*1.3*c,\n                        a.y*3. + cos(time*0.14)*1.5*c + sin(time*0.2)*0.8*c));\n    float alphaCg = 1.0 - smoothstep(w, w + aa, abs(d));\n    cumulativeCol = mix(cumulativeCol, vec4(cg * add, alphaCg), alphaCg);\n\n    \/\/ Mirror current coords\n    a = -a;\n    \/\/ Readjust left strokes\n    vec2 adj = vec2(3.45, -1.);\n\n    \/\/ Left red segment\n    d = sdSegment(nuv + adj - c*vec2(sin(time*0.9)*4. + 3., cos(time*0.18)*-1.5),\n                  -a + vec2(cos(time*0.12)*1.4, sin(time*0.14+time*0.03)*1.2)*c,\n                  a - vec2(sin(time*0.16)*1.3, cos(time*0.11)*1.5 + sin(time*0.07)*0.9)*c);\n    float alphaCr = 1.0 - smoothstep(w, w + aa, abs(d));\n    cumulativeCol = mix(cumulativeCol, vec4(cr * add, alphaCr), alphaCr);\n\n    \/\/ Left blue segment\n    d = sdSegment(nuv + adj + c*vec2(sin(time*0.9)*4. - 5., cos(time*0.18)*1.5),\n                  a - vec2(cos(time*0.15)*1.2, sin(time*0.13)*1.3)*c,\n                  vec2(-a.x - cos(time*0.11+time*0.06)*1.4*c, \n                        a.y*3. + sin(time*0.1)*1.6*c + sin(time*0.09)*1.1*c));\n    float alphaCb = 1.0 - smoothstep(w, w + aa, abs(d));\n    cumulativeCol = mix(cumulativeCol, vec4(cb * add, alphaCb), alphaCb);\n\n    \/\/ Blend final logo color with the background based on alpha\n    vec3 finalCol = mix(bg, cumulativeCol.rgb, clamp(cumulativeCol.a, 0.0, 1.0));\n\n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ [0.0, 0.0] coordinate system\n    vec2 uv = (2. * fragCoord - iResolution.xy) \/ iResolution.y;\n    \n    \/\/ Vertical align for the slide\n    uv.y += .27;\n    \/\/ Smooter movements\n    \/\/ Scale linearly until good zoom level\n    \/\/uv \/= min(((iTime\/5.)-8.)\/5.+2.0, 7.0);\n    \n    \/\/uv = fract(uv*2.);\n    \n    uv *= 3.333;\n\n    \/\/ BG\n    vec3 col = vec3(0.2, 0.17, 0.19);\n\n    \/\/ Do blobs with random movements\n    \/\/col = mix(col, cr, flare(uv, vec2(-0.4, 0.0) * sin(t-45.)));\n    \/\/col = mix(col, cb, flare(uv, vec2(-0.5, 0.2) * sin(-t*0.666) * cos(-t+33.)));\n    \/\/col = mix(col, cy, flare(uv, vec2(0.13, -0.69) * sin(t-2.)));\n    \/\/col = mix(col, cg, flare(uv, vec2(-0.5, 0.9) * sin(t)*cos(t\/2.)));\n    \n    vec3 gdg = gdgLogo(uv, col);\n    col = mix(col, gdg*1.1, length(gdg));\n    \n    \/\/ Move > 1. colors to 1.\n    col = min(col, vec3(1.));\n\n    \/\/ Vignnete to avoid overexpossure\n    col -= vec3(1.) * dot(uv, uv)\/150.;\n    \n    \/\/ Apply dithering if needed\n    #ifdef DITHERING\n    col += (1.0 \/ 255.0) * gradientNoise(gl_FragCoord.xy) - (0.5 \/ 255.0);\n    #endif\n\n    \/\/ Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}]